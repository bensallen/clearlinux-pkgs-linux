From: Arjan van de Ven <arjan@linux.intel.com>
Subject: reduce e1000e boot time by tightening sleep ranges

The e1000e driver is a great user of the usleep_range() API,
and has any nice ranges that in principle help power management.

However the ranges that are used only during system startup are
very long (and can add easily 100 msec to the boot time) while
the power savings of such long ranges is irrelevant due to the
one-off, boot only, nature of these functions.

This patch shrinks some of the longest ranges to be shorter
(while still using a power friendly 1 msec range); this saves
100msec+ of boot time on my BDW NUCs

Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>



diff -purN linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/80003es2lan.c linux-4.6.1/drivers/net/ethernet/intel/e1000e/80003es2lan.c
--- linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/80003es2lan.c	2016-06-01 19:18:22.000000000 +0000
+++ linux-4.6.1/drivers/net/ethernet/intel/e1000e/80003es2lan.c	2016-06-04 16:47:06.269898333 +0000
@@ -698,7 +698,7 @@ static s32 e1000_reset_hw_80003es2lan(st
 	ew32(TCTL, E1000_TCTL_PSP);
 	e1e_flush();
 
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	ctrl = er32(CTRL);
 
diff -purN linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/82571.c linux-4.6.1/drivers/net/ethernet/intel/e1000e/82571.c
--- linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/82571.c	2016-06-01 19:18:22.000000000 +0000
+++ linux-4.6.1/drivers/net/ethernet/intel/e1000e/82571.c	2016-06-04 16:47:16.877773046 +0000
@@ -977,7 +977,7 @@ static s32 e1000_reset_hw_82571(struct e
 	ew32(TCTL, tctl);
 	e1e_flush();
 
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	/* Must acquire the MDIO ownership before MAC reset.
 	 * Ownership defaults to firmware after a reset.
diff -purN linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/ethtool.c linux-4.6.1/drivers/net/ethernet/intel/e1000e/ethtool.c
--- linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/ethtool.c	2016-06-01 19:18:22.000000000 +0000
+++ linux-4.6.1/drivers/net/ethernet/intel/e1000e/ethtool.c	2016-06-04 16:47:57.672291261 +0000
@@ -1014,7 +1014,7 @@ static int e1000_intr_test(struct e1000_
 	/* Disable all the interrupts */
 	ew32(IMC, 0xFFFFFFFF);
 	e1e_flush();
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	/* Test each interrupt */
 	for (i = 0; i < 10; i++) {
@@ -1046,7 +1046,7 @@ static int e1000_intr_test(struct e1000_
 			ew32(IMC, mask);
 			ew32(ICS, mask);
 			e1e_flush();
-			usleep_range(10000, 20000);
+			usleep_range(10000, 11000);
 
 			if (adapter->test_icr & mask) {
 				*data = 3;
@@ -1064,7 +1064,7 @@ static int e1000_intr_test(struct e1000_
 		ew32(IMS, mask);
 		ew32(ICS, mask);
 		e1e_flush();
-		usleep_range(10000, 20000);
+		usleep_range(10000, 11000);
 
 		if (!(adapter->test_icr & mask)) {
 			*data = 4;
@@ -1082,7 +1082,7 @@ static int e1000_intr_test(struct e1000_
 			ew32(IMC, ~mask & 0x00007FFF);
 			ew32(ICS, ~mask & 0x00007FFF);
 			e1e_flush();
-			usleep_range(10000, 20000);
+			usleep_range(10000, 11000);
 
 			if (adapter->test_icr) {
 				*data = 5;
@@ -1094,7 +1094,7 @@ static int e1000_intr_test(struct e1000_
 	/* Disable all the interrupts */
 	ew32(IMC, 0xFFFFFFFF);
 	e1e_flush();
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	/* Unhook test interrupt handler */
 	free_irq(irq, netdev);
@@ -1470,7 +1470,7 @@ static int e1000_set_82571_fiber_loopbac
 	 */
 	ew32(SCTL, E1000_SCTL_ENABLE_SERDES_LOOPBACK);
 	e1e_flush();
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	return 0;
 }
@@ -1583,7 +1583,7 @@ static void e1000_loopback_cleanup(struc
 		    hw->phy.media_type == e1000_media_type_internal_serdes) {
 			ew32(SCTL, E1000_SCTL_DISABLE_SERDES_LOOPBACK);
 			e1e_flush();
-			usleep_range(10000, 20000);
+			usleep_range(10000, 11000);
 			break;
 		}
 		/* Fall Through */
diff -purN linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/ich8lan.c linux-4.6.1/drivers/net/ethernet/intel/e1000e/ich8lan.c
--- linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/ich8lan.c	2016-06-01 19:18:22.000000000 +0000
+++ linux-4.6.1/drivers/net/ethernet/intel/e1000e/ich8lan.c	2016-06-04 16:49:11.763416236 +0000
@@ -289,7 +289,7 @@ static void e1000_toggle_lanphypc_pch_lp
 		u16 count = 20;
 
 		do {
-			usleep_range(5000, 10000);
+			usleep_range(5000, 6000);
 		} while (!(er32(CTRL_EXT) & E1000_CTRL_EXT_LPCD) && count--);
 
 		msleep(30);
@@ -422,7 +422,7 @@ out:
 	/* Ungate automatic PHY configuration on non-managed 82579 */
 	if ((hw->mac.type == e1000_pch2lan) &&
 	    !(fwsm & E1000_ICH_FWSM_FW_VALID)) {
-		usleep_range(10000, 20000);
+		usleep_range(10000, 11000);
 		e1000_gate_hw_phy_config_ich8lan(hw, false);
 	}
 
@@ -547,7 +547,7 @@ static s32 e1000_init_phy_params_ich8lan
 	phy->id = 0;
 	while ((e1000_phy_unknown == e1000e_get_phy_type_from_id(phy->id)) &&
 	       (i++ < 100)) {
-		usleep_range(1000, 2000);
+		usleep_range(1000, 1100);
 		ret_val = e1000e_get_phy_id(hw);
 		if (ret_val)
 			return ret_val;
@@ -1259,7 +1259,7 @@ static s32 e1000_disable_ulp_lpt_lp(stru
 				goto out;
 			}
 
-			usleep_range(10000, 20000);
+			usleep_range(10000, 11000);
 		}
 		e_dbg("ULP_CONFIG_DONE cleared after %dmsec\n", i * 10);
 
@@ -2011,7 +2011,7 @@ static s32 e1000_check_reset_block_ich8l
 
 	while ((blocked = !(er32(FWSM) & E1000_ICH_FWSM_RSPCIPHY)) &&
 	       (i++ < 30))
-		usleep_range(10000, 20000);
+		usleep_range(10000, 11000);
 	return blocked ? E1000_BLK_PHY_RESET : 0;
 }
 
@@ -2827,7 +2827,7 @@ static s32 e1000_post_phy_reset_ich8lan(
 		return 0;
 
 	/* Allow time for h/w to get to quiescent state after reset */
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	/* Perform any necessary post-reset workarounds */
 	switch (hw->mac.type) {
@@ -2863,7 +2863,7 @@ static s32 e1000_post_phy_reset_ich8lan(
 	if (hw->mac.type == e1000_pch2lan) {
 		/* Ungate automatic PHY configuration on non-managed 82579 */
 		if (!(er32(FWSM) & E1000_ICH_FWSM_FW_VALID)) {
-			usleep_range(10000, 20000);
+			usleep_range(10000, 11000);
 			e1000_gate_hw_phy_config_ich8lan(hw, false);
 		}
 
@@ -3884,7 +3884,7 @@ release:
 	 */
 	if (!ret_val) {
 		nvm->ops.reload(hw);
-		usleep_range(10000, 20000);
+		usleep_range(10000, 11000);
 	}
 
 out:
@@ -4035,7 +4035,7 @@ release:
 	 */
 	if (!ret_val) {
 		nvm->ops.reload(hw);
-		usleep_range(10000, 20000);
+		usleep_range(10000, 11000);
 	}
 
 out:
@@ -4658,7 +4658,7 @@ static s32 e1000_reset_hw_ich8lan(struct
 	ew32(TCTL, E1000_TCTL_PSP);
 	e1e_flush();
 
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	/* Workaround for ICH8 bit corruption issue in FIFO memory */
 	if (hw->mac.type == e1000_ich8lan) {
diff -purN linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/mac.c linux-4.6.1/drivers/net/ethernet/intel/e1000e/mac.c
--- linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/mac.c	2016-06-01 19:18:22.000000000 +0000
+++ linux-4.6.1/drivers/net/ethernet/intel/e1000e/mac.c	2016-06-04 16:49:29.627205270 +0000
@@ -815,7 +815,7 @@ static s32 e1000_poll_fiber_serdes_link_
 	 * milliseconds even if the other end is doing it in SW).
 	 */
 	for (i = 0; i < FIBER_LINK_UP_LIMIT; i++) {
-		usleep_range(10000, 20000);
+		usleep_range(10000, 11000);
 		status = er32(STATUS);
 		if (status & E1000_STATUS_LU)
 			break;
diff -purN linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/netdev.c linux-4.6.1/drivers/net/ethernet/intel/e1000e/netdev.c
--- linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/netdev.c	2016-06-01 19:18:22.000000000 +0000
+++ linux-4.6.1/drivers/net/ethernet/intel/e1000e/netdev.c	2016-06-04 16:50:09.903729597 +0000
@@ -3206,7 +3206,7 @@ static void e1000_configure_rx(struct e1
 	if (!(adapter->flags2 & FLAG2_NO_DISABLE_RX))
 		ew32(RCTL, rctl & ~E1000_RCTL_EN);
 	e1e_flush();
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	if (adapter->flags2 & FLAG2_DMA_BURST) {
 		/* set the writeback threshold (only takes effect if the RDTR
@@ -4222,7 +4222,7 @@ void e1000e_down(struct e1000_adapter *a
 
 	/* flush both disables and wait for them to finish */
 	e1e_flush();
-	usleep_range(10000, 20000);
+	usleep_range(10000, 11000);
 
 	e1000_irq_disable(adapter);
 
@@ -4260,7 +4260,7 @@ void e1000e_reinit_locked(struct e1000_a
 {
 	might_sleep();
 	while (test_and_set_bit(__E1000_RESETTING, &adapter->state))
-		usleep_range(1000, 2000);
+		usleep_range(1000, 1100);
 	e1000e_down(adapter, true);
 	e1000e_up(adapter);
 	clear_bit(__E1000_RESETTING, &adapter->state);
@@ -4621,7 +4621,7 @@ static int e1000_close(struct net_device
 	int count = E1000_CHECK_RESET_COUNT;
 
 	while (test_bit(__E1000_RESETTING, &adapter->state) && count--)
-		usleep_range(10000, 20000);
+		usleep_range(10000, 11000);
 
 	WARN_ON(test_bit(__E1000_RESETTING, &adapter->state));
 
@@ -5946,7 +5946,7 @@ static int e1000_change_mtu(struct net_d
 	}
 
 	while (test_and_set_bit(__E1000_RESETTING, &adapter->state))
-		usleep_range(1000, 2000);
+		usleep_range(1000, 1100);
 	/* e1000e_down -> e1000e_reset dependent on max_frame_size & mtu */
 	adapter->max_frame_size = max_frame;
 	e_info("changing MTU from %d to %d\n", netdev->mtu, new_mtu);
@@ -6226,7 +6226,7 @@ static int e1000e_pm_freeze(struct devic
 		int count = E1000_CHECK_RESET_COUNT;
 
 		while (test_bit(__E1000_RESETTING, &adapter->state) && count--)
-			usleep_range(10000, 20000);
+			usleep_range(10000, 11000);
 
 		WARN_ON(test_bit(__E1000_RESETTING, &adapter->state));
 
@@ -6637,7 +6637,7 @@ static int e1000e_pm_runtime_suspend(str
 		int count = E1000_CHECK_RESET_COUNT;
 
 		while (test_bit(__E1000_RESETTING, &adapter->state) && count--)
-			usleep_range(10000, 20000);
+			usleep_range(10000, 11000);
 
 		WARN_ON(test_bit(__E1000_RESETTING, &adapter->state));
 
diff -purN linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/nvm.c linux-4.6.1/drivers/net/ethernet/intel/e1000e/nvm.c
--- linux-4.6.1/drivers/net/ethernet/intel/e1000e.org/nvm.c	2016-06-01 19:18:22.000000000 +0000
+++ linux-4.6.1/drivers/net/ethernet/intel/e1000e/nvm.c	2016-06-04 16:50:18.761624985 +0000
@@ -410,7 +410,7 @@ s32 e1000e_write_nvm_spi(struct e1000_hw
 				break;
 			}
 		}
-		usleep_range(10000, 20000);
+		usleep_range(10000, 11000);
 		nvm->ops.release(hw);
 	}
 
